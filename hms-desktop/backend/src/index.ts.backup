const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
require('dotenv').config();
const { PrismaClient } = require('@prisma/client');

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Initialize Prisma Client
const prisma = new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],
});

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  credentials: true,
}));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Simple request logging middleware
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`üì• ${req.method} ${req.path} - ${new Date().toISOString()}`);
  
  const originalEnd = res.end;
  res.end = function(chunk, encoding) {
    const duration = Date.now() - start;
    const statusColor = res.statusCode >= 400 ? 'üî¥' : res.statusCode >= 300 ? 'üü°' : 'üü¢';
    console.log(`üì§ ${statusColor} ${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);
    return originalEnd.call(this, chunk, encoding);
  };
  
  next();
});

// Health check endpoint (MUST be defined before routes so it's always available)
app.get('/health', (req, res) => {
  res.status(200).json({
    success: true,
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development',
    version: process.env.APP_VERSION || '1.0.0',
    message: 'HMS Backend Server is running!'
  });
});

// Load routes asynchronously after server starts (routes are TypeScript, need ts-node)
// For now, skip route loading in JS mode - they'll work with ts-node
if (process.env.USE_TS_NODE !== 'false') {
  try {
    // Try to load routes - will work if using ts-node
    const routes = [
      { path: '/api/patients', module: './routes/patients', exportName: 'patientRoutes' },
      { path: '/api/appointments', module: './routes/appointments', exportName: 'appointmentRoutes' },
      { path: '/api/prescriptions', module: './routes/prescriptions', exportName: 'prescriptionRoutes' },
      { path: '/api/lab-tests', module: './routes/labTests', exportName: 'labTestRoutes' },
    ];

    routes.forEach(route => {
      try {
        const routeModule = require(route.module);
        const routeHandler = routeModule[route.exportName] || routeModule.default || routeModule.router;
        if (routeHandler) {
          app.use(route.path, routeHandler);
          console.log(`‚úÖ ${route.path} routes mounted successfully`);
        }
      } catch (error) {
        // Routes are TypeScript - skip in JS mode
        console.warn(`‚ö†Ô∏è  ${route.path}: Skipping (TypeScript routes require ts-node)`);
      }
    });
  } catch (error) {
    console.warn('‚ö†Ô∏è  Routes are TypeScript files - will work with ts-node');
  }
}

// Simple auth endpoint for testing
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: 'Username and password are required'
      });
    }

    // Find user
    const user = await prisma.user.findUnique({
      where: { username },
    });

    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // For now, just return success (we'll add proper password checking later)
    res.json({
      success: true,
      message: 'Login successful',
      data: {
        user: {
          id: user.id,
          username: user.username,
          fullName: user.fullName,
          role: user.role,
        },
        token: 'dummy-token-for-testing'
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'API endpoint not found',
    path: req.originalUrl,
  });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Error:', error);
  res.status(500).json({
    success: false,
    message: 'Something went wrong'
  });
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Received SIGINT, shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

// Start server
const startServer = async () => {
  try {
    // Test database connection with timeout
    console.log('üîå Connecting to database...');
    const connectPromise = prisma.$connect();
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Database connection timeout after 10 seconds')), 10000)
    );
    
    try {
      await Promise.race([connectPromise, timeoutPromise]);
      console.log('‚úÖ Database connected successfully');
    } catch (dbError) {
      console.error('‚ùå Database connection failed:', dbError.message);
      console.error('‚ö†Ô∏è  Please check:');
      console.error('   1. DATABASE_URL is set in .env file');
      console.error('   2. PostgreSQL server is running');
      console.error('   3. Database credentials are correct');
      console.error('\nüí° Server will start but database operations will fail until connection is established.\n');
      // Continue anyway - server can start without DB for health checks
    }

    // Start the server
    const server = app.listen(PORT, () => {
      console.log(`üöÄ HMS Backend Server running on port ${PORT}`);
      console.log(`üìä Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`üîó API Base URL: http://localhost:${PORT}/api`);
      console.log(`üè• Health Check: http://localhost:${PORT}/health`);
      console.log(`üè• Hospital: ${process.env.HOSPITAL_NAME || 'HMS System'}`);
      console.log('\nüìã Available endpoints:');
      console.log(`   GET  http://localhost:${PORT}/health`);
      console.log(`   POST http://localhost:${PORT}/api/auth/login`);
      console.log(`   GET  http://localhost:${PORT}/api/patients`);
      console.log(`   POST http://localhost:${PORT}/api/patients`);
      console.log(`   GET  http://localhost:${PORT}/api/patients/stats`);
      console.log(`   GET  http://localhost:${PORT}/api/appointments`);
      console.log(`   POST http://localhost:${PORT}/api/appointments`);
      console.log(`   GET  http://localhost:${PORT}/api/appointments/stats`);
      console.log(`   GET  http://localhost:${PORT}/api/prescriptions`);
      console.log(`   POST http://localhost:${PORT}/api/prescriptions`);
      console.log(`   GET  http://localhost:${PORT}/api/prescriptions/stats`);
      console.log(`   GET  http://localhost:${PORT}/api/lab-tests`);
      console.log(`   POST http://localhost:${PORT}/api/lab-tests`);
      console.log(`   GET  http://localhost:${PORT}/api/lab-tests/stats`);
      console.log('\n‚úÖ Server is ready to accept requests!\n');
    });

    // Handle server errors
    server.on('error', (error) => {
      if (error.code === 'EADDRINUSE') {
        console.error(`‚ùå Port ${PORT} is already in use. Please stop the other process or use a different port.`);
        process.exit(1);
      } else {
        console.error('‚ùå Server error:', error);
        process.exit(1);
      }
    });

  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    if (error.stack) {
      console.error('Stack trace:', error.stack);
    }
    try {
      await prisma.$disconnect();
    } catch (disconnectError) {
      // Ignore disconnect errors
    }
    process.exit(1);
  }
};

// Start the server
startServer();

module.exports = app;
